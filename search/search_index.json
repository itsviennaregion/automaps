{"config":{"indexing":"full","lang":["en"],"min_search_length":3,"prebuild_index":false,"separator":"[\\s\\-]+"},"docs":[{"location":"","text":"Welcome to autoMaps # Automatically generate customized and ready to print maps With autoMaps, you can: prepare your map layouts in QGIS let your users define map parameters in a nice web frontend receive beautiful, ready to print maps as PDFs or in other file formats Give your domain experts the power to create maps like a GIS pro! Start by reading the Getting Started Tutorial , then check the User Guide for more details. Features # Pre-define your map layouts, let your users set the map parameters # Use the power of a GIS, serve the maps over the web # Easy to configure # Builds on reliable open source projects #","title":"Home"},{"location":"#welcome-to-automaps","text":"Automatically generate customized and ready to print maps With autoMaps, you can: prepare your map layouts in QGIS let your users define map parameters in a nice web frontend receive beautiful, ready to print maps as PDFs or in other file formats Give your domain experts the power to create maps like a GIS pro! Start by reading the Getting Started Tutorial , then check the User Guide for more details.","title":"Welcome to autoMaps"},{"location":"#features","text":"","title":"Features"},{"location":"#pre-define-your-map-layouts-let-your-users-set-the-map-parameters","text":"","title":"Pre-define your map layouts, let your users set the map parameters"},{"location":"#use-the-power-of-a-gis-serve-the-maps-over-the-web","text":"","title":"Use the power of a GIS, serve the maps over the web"},{"location":"#easy-to-configure","text":"","title":"Easy to configure"},{"location":"#builds-on-reliable-open-source-projects","text":"","title":"Builds on reliable open source projects"},{"location":"about/","text":"","title":"About"},{"location":"getting_started/","text":"Getting Started with autoMaps # Work through this tutorial to get your feets wet with autoMaps. For further details on using autoMaps, please refer to the User Guide . Installation # Warning Only tested on Ubuntu 20.04! autoMaps uses QGIS , a free and open source geographic information system, to generate maps. Get it on the QGIS downloads page and install it first. You probably should be familiar with QGIS and at least a little bit of PyQGIS to get most out of autoMaps. Check out the QGIS documentation , if necessary. Then open your command line and clone the autoMaps repository: git clone https://github.com/itsviennaregion/automaps.git Change into the cloned directory: cd automaps Install the automaps package for the Python interpreter used by QGIS , for example like this: /usr/bin/python3 -m pip install . Info If you are not sure, which Python interpreter is used by QGIS, open the QGIS GUI and run the following commands in the Python console: import sys sys.executable This may return something like /usr/bin/python3 . Use the path to this Python interpreter in the command above. Creating a demo project # To get a feeling for the functionality and configuration of autoMaps you should first create a demo project. On the command line, cd into a directory where you want to place the demo project. Then run the following command: automaps init-demo Then start the demo app by running the following command: automaps run dev -c ./automaps-demo/automapsconf.py Open up http://127.0.0.1:8506/automaps-demo/ in your browser, and you'll see the frontend of the demo project being displayed: Choose a district and a file format, click on Create map and then on Download to get your first automatically generated map. Tip If you encounter problems running the demo app, this might be because of a wrong setting in automaps-demo/automapsconf.py . Try to change the option QGIS_INSTALLATION_PATH to the correct path for your system. The path can be determined by opening up the QGIS GUI and running QgsApplication.prefixPath() in the Python console. Exploring the demo project # The demo project consists of the following files: Geodata ( demo_data.gpkg , demo_project.qgz ) # Let's take a look at the geodata first. It is stored in the GeoPackage demo_data.gpkg and used in the QGIS project demo_project.qgz . Open the qgz file with QGIS and explore it. You'll discover, that it consists of only a few main elements. It has two layers: districts : a polygon layer holding the geometries and some attributes of the 23 districts of Vienna, Austria. The attribute NAMEK is used to provide the options for the frontend's drop down menu called District name . During the map creation process, the districts layer is filtered to only show the selected district. OpenStreetMap : used as basemap. The project also consists of a print layout called poly , which has three elements: The main map, called Map 1 . During the map creation process, the map view is updated to zoom to the selected district. A label with the content [% map_get(@data, 'District name') %] . During the map creation process, it is updated to hold the selected value of the drop down menu called District name . Another label holding the data source information. This is just some static text. The streamlit configuration ( ./streamlit/config.toml ) # autoMaps uses Streamlit as its frontend. Streamlit can be configured using the config.toml file, as described in the docs . In the case of our demo project, it looks like this: [server] port = 8506 baseUrlPath = \"automaps-demo\" The main configuration ( automapsconf.py , automapsconf_poly.py , db.py ) # The main configuration is defined in a Python file, which typically is called automapsconf.py and located in the same directory as app.py . For the demo project this configuration is split into three files, two of them imported into the main file automapsconf.py . This helps to keep everything clearly arranged and to store database credentials in a dedicated file, which can be kept locally in version control scenarios (e.g. by gitignoring it). This structure is recommended as best practice for your own projects. For more information take a look at the User Guide . automapsconf.py requires some mandatory config options and supports a list of optional config options. At this point, we will focus only on two of them, db and MAPTYPES_AVAIL : The configuration option db is necessary to connect to your project's (geo)database and thus to present the available options in the frontend (like the values of the drop down menu District name ). It has to be a dictionary which can be converted to an SQLAlchemy URL object . For the demo project, only drivername and database are set to point to the SQLite database which is part of the geopackage demo_data.gpkg : db = { \"drivername\" : \"sqlite\" , \"database\" : \"demo_data.gpkg\" } The configuration option MAPTYPES_AVAIL is a list of MapType objects: MAPTYPES_AVAIL = [ maptype_poly ] MapType objects serve as main autoMaps elements and help to structure your project. Each MapType is tied to one or more QGIS print layouts (which define the looks of the map) as well as to a single MapGenerator (which defines the processing steps). Take a look at the code in automapsconf_poly.py which defines the MapType object maptype_poly and compare it with the UI elements of the demo project's frontend: import streamlit as st from automaps.maptype import MapType from automaps.selector import SelectorSimple , SelectorSQL from generate_poly import MapGeneratorPoly maptype_poly = MapType ( name = \"Districts in Vienna\" , description = \"Choose a district and get your map!\" , ui_elements = [ SelectorSQL ( \"District name\" , \"\"\" select distinct NAMEK from districtborder order by NAMEK\"\"\" , st . selectbox , widget_args = { \"help\" : \"Choose your district!\" }, no_value_selected_text = \"Choose district ...\" , ), SelectorSimple ( \"File Format\" , [ \"PDF\" , \"PNG\" , \"SVG\" ], st . radio , exclude_from_filename = True , use_for_file_format = True , ), ], print_layout = \"poly\" , map_generator = MapGeneratorPoly , ) You can see that the main part of the object initialization is the list passed to the ui_elements argument. It holds two Selector objects, which define the available options in the frontend and serve as connection to the backend, passing the selected values as a dictionary called data to the processing machinery. Check the \"Debug\" box in the frontend to see a representation of the data object: The processing configuration ( generate_poly.py ) # The data dictionary is consumed by MapGeneratorPoly , a class of type MapGenerator , defined in generate_poly.py : from collections import OrderedDict from automaps.generators.base import MapGenerator , Step class MapGeneratorPoly ( MapGenerator ): name = \"Districts in Vienna\" def _set_steps ( self ): self . steps = OrderedDict ( { \"Initialize project\" : Step ( self . init_project , 1 ), \"Filter layers\" : Step ( self . filter_layers , 1 ), \"Zoom to extent\" : Step ( self . set_extent , 1 ), \"Export map\" : Step ( self . export_layout , 5 ), } ) def init_project ( self ): self . _init_layers () self . _set_project_variable ( \"data\" , self . data ) self . _set_map_layer_visibility ( \"districts\" , True ) self . _set_map_layer_visibility ( \"OpenStreetMap\" , True ) def filter_layers ( self ): self . _set_map_layer_filter_expression ( \"districts\" , f \"NAMEK = ' { self . data [ 'District name' ] } '\" ) def set_extent ( self ): self . _zoom_map_to_layer_extent ( \"Map 1\" , self . _get_map_layer ( \"districts\" ) ) def export_layout ( self ): self . _export_print_layout ( self . step_data . layout ) self . step_data . project . write ( \"./poly_out.qgz\" ) del self . step_data . project The MapGenerator defines the processing steps which are required to generate the desired map, based on (1) the user selected options (stored in the self.data property), and (2) on the layers, stylings, print layouts etc. in the QGIS project. Each MapGenerator consists of at least one, but possibly dozens of processing steps. The demo project's MapGeneratorPoly consists of four. They are declared in the _set_steps() method and defined in the other corresponding methods. How to structure your MapGenerator depends on your use case. Just take notice, that the progress of a processing task is visualized in the frontend as a progress bar. You can call your methods however you want. So what happens here? init_project() initializes all map layers, making them invisible and removing all filter conditions. It copies the self.data dictionary as project variable into the QGIS project and then turns on the required layers. filter_layers() takes the user selected value of the Selector labeled District name (the drop down menu) to set a filter expression for the districts layer. set_extent() zooms Map 1 of our print layout poly to the now filtered extent of the districts layer. export_layout() finally exports the created map in the desired file format (PDF, PNG or SVG). It also writes the specific QGIS project file to the defined location, which can be handy for debugging your own autoMaps projects. Take a look at poly_out.qgz in QGIS, inspect the filter expressions and the poly print layout! The step methods use various helper methods, inherited from the MapGenerator base class, such as _set_map_layer_visibility() or _export_print_layout() . Take a look at the User Guide for a list of these helper methods. You don't have to use them in your own projects, you could directly go for the respective PyQGIS -calls instead. But they save you a lof of typing for the most common tasks. After running through all processing steps, the download button shows up on the frontend and the map is ready to be used. Feel free to play around with the demo project to get better acquainted with the overall structure of an autoMaps project. For further details on using autoMaps, please refer to the User Guide ! Creating your own project # You can now go back to the command line and create your first autoMaps project from scratch. Run the following command: automaps init-project PROJECT_NAME Replace PROJECT_NAME with the desired name. This will create a new directory with some stub files as starting point for your own project. Maybe you like to start with editing automapsconf.py which includes some hopefully helpful comments to get you started.","title":"Getting Started"},{"location":"getting_started/#getting-started-with-automaps","text":"Work through this tutorial to get your feets wet with autoMaps. For further details on using autoMaps, please refer to the User Guide .","title":"Getting Started with autoMaps"},{"location":"getting_started/#installation","text":"Warning Only tested on Ubuntu 20.04! autoMaps uses QGIS , a free and open source geographic information system, to generate maps. Get it on the QGIS downloads page and install it first. You probably should be familiar with QGIS and at least a little bit of PyQGIS to get most out of autoMaps. Check out the QGIS documentation , if necessary. Then open your command line and clone the autoMaps repository: git clone https://github.com/itsviennaregion/automaps.git Change into the cloned directory: cd automaps Install the automaps package for the Python interpreter used by QGIS , for example like this: /usr/bin/python3 -m pip install . Info If you are not sure, which Python interpreter is used by QGIS, open the QGIS GUI and run the following commands in the Python console: import sys sys.executable This may return something like /usr/bin/python3 . Use the path to this Python interpreter in the command above.","title":"Installation"},{"location":"getting_started/#creating-a-demo-project","text":"To get a feeling for the functionality and configuration of autoMaps you should first create a demo project. On the command line, cd into a directory where you want to place the demo project. Then run the following command: automaps init-demo Then start the demo app by running the following command: automaps run dev -c ./automaps-demo/automapsconf.py Open up http://127.0.0.1:8506/automaps-demo/ in your browser, and you'll see the frontend of the demo project being displayed: Choose a district and a file format, click on Create map and then on Download to get your first automatically generated map. Tip If you encounter problems running the demo app, this might be because of a wrong setting in automaps-demo/automapsconf.py . Try to change the option QGIS_INSTALLATION_PATH to the correct path for your system. The path can be determined by opening up the QGIS GUI and running QgsApplication.prefixPath() in the Python console.","title":"Creating a demo project"},{"location":"getting_started/#exploring-the-demo-project","text":"The demo project consists of the following files:","title":"Exploring the demo project"},{"location":"getting_started/#geodata-demo_datagpkg-demo_projectqgz","text":"Let's take a look at the geodata first. It is stored in the GeoPackage demo_data.gpkg and used in the QGIS project demo_project.qgz . Open the qgz file with QGIS and explore it. You'll discover, that it consists of only a few main elements. It has two layers: districts : a polygon layer holding the geometries and some attributes of the 23 districts of Vienna, Austria. The attribute NAMEK is used to provide the options for the frontend's drop down menu called District name . During the map creation process, the districts layer is filtered to only show the selected district. OpenStreetMap : used as basemap. The project also consists of a print layout called poly , which has three elements: The main map, called Map 1 . During the map creation process, the map view is updated to zoom to the selected district. A label with the content [% map_get(@data, 'District name') %] . During the map creation process, it is updated to hold the selected value of the drop down menu called District name . Another label holding the data source information. This is just some static text.","title":"Geodata (demo_data.gpkg, demo_project.qgz)"},{"location":"getting_started/#the-streamlit-configuration-streamlitconfigtoml","text":"autoMaps uses Streamlit as its frontend. Streamlit can be configured using the config.toml file, as described in the docs . In the case of our demo project, it looks like this: [server] port = 8506 baseUrlPath = \"automaps-demo\"","title":"The streamlit configuration (./streamlit/config.toml)"},{"location":"getting_started/#the-main-configuration-automapsconfpy-automapsconf_polypy-dbpy","text":"The main configuration is defined in a Python file, which typically is called automapsconf.py and located in the same directory as app.py . For the demo project this configuration is split into three files, two of them imported into the main file automapsconf.py . This helps to keep everything clearly arranged and to store database credentials in a dedicated file, which can be kept locally in version control scenarios (e.g. by gitignoring it). This structure is recommended as best practice for your own projects. For more information take a look at the User Guide . automapsconf.py requires some mandatory config options and supports a list of optional config options. At this point, we will focus only on two of them, db and MAPTYPES_AVAIL : The configuration option db is necessary to connect to your project's (geo)database and thus to present the available options in the frontend (like the values of the drop down menu District name ). It has to be a dictionary which can be converted to an SQLAlchemy URL object . For the demo project, only drivername and database are set to point to the SQLite database which is part of the geopackage demo_data.gpkg : db = { \"drivername\" : \"sqlite\" , \"database\" : \"demo_data.gpkg\" } The configuration option MAPTYPES_AVAIL is a list of MapType objects: MAPTYPES_AVAIL = [ maptype_poly ] MapType objects serve as main autoMaps elements and help to structure your project. Each MapType is tied to one or more QGIS print layouts (which define the looks of the map) as well as to a single MapGenerator (which defines the processing steps). Take a look at the code in automapsconf_poly.py which defines the MapType object maptype_poly and compare it with the UI elements of the demo project's frontend: import streamlit as st from automaps.maptype import MapType from automaps.selector import SelectorSimple , SelectorSQL from generate_poly import MapGeneratorPoly maptype_poly = MapType ( name = \"Districts in Vienna\" , description = \"Choose a district and get your map!\" , ui_elements = [ SelectorSQL ( \"District name\" , \"\"\" select distinct NAMEK from districtborder order by NAMEK\"\"\" , st . selectbox , widget_args = { \"help\" : \"Choose your district!\" }, no_value_selected_text = \"Choose district ...\" , ), SelectorSimple ( \"File Format\" , [ \"PDF\" , \"PNG\" , \"SVG\" ], st . radio , exclude_from_filename = True , use_for_file_format = True , ), ], print_layout = \"poly\" , map_generator = MapGeneratorPoly , ) You can see that the main part of the object initialization is the list passed to the ui_elements argument. It holds two Selector objects, which define the available options in the frontend and serve as connection to the backend, passing the selected values as a dictionary called data to the processing machinery. Check the \"Debug\" box in the frontend to see a representation of the data object:","title":"The main configuration (automapsconf.py, automapsconf_poly.py, db.py)"},{"location":"getting_started/#the-processing-configuration-generate_polypy","text":"The data dictionary is consumed by MapGeneratorPoly , a class of type MapGenerator , defined in generate_poly.py : from collections import OrderedDict from automaps.generators.base import MapGenerator , Step class MapGeneratorPoly ( MapGenerator ): name = \"Districts in Vienna\" def _set_steps ( self ): self . steps = OrderedDict ( { \"Initialize project\" : Step ( self . init_project , 1 ), \"Filter layers\" : Step ( self . filter_layers , 1 ), \"Zoom to extent\" : Step ( self . set_extent , 1 ), \"Export map\" : Step ( self . export_layout , 5 ), } ) def init_project ( self ): self . _init_layers () self . _set_project_variable ( \"data\" , self . data ) self . _set_map_layer_visibility ( \"districts\" , True ) self . _set_map_layer_visibility ( \"OpenStreetMap\" , True ) def filter_layers ( self ): self . _set_map_layer_filter_expression ( \"districts\" , f \"NAMEK = ' { self . data [ 'District name' ] } '\" ) def set_extent ( self ): self . _zoom_map_to_layer_extent ( \"Map 1\" , self . _get_map_layer ( \"districts\" ) ) def export_layout ( self ): self . _export_print_layout ( self . step_data . layout ) self . step_data . project . write ( \"./poly_out.qgz\" ) del self . step_data . project The MapGenerator defines the processing steps which are required to generate the desired map, based on (1) the user selected options (stored in the self.data property), and (2) on the layers, stylings, print layouts etc. in the QGIS project. Each MapGenerator consists of at least one, but possibly dozens of processing steps. The demo project's MapGeneratorPoly consists of four. They are declared in the _set_steps() method and defined in the other corresponding methods. How to structure your MapGenerator depends on your use case. Just take notice, that the progress of a processing task is visualized in the frontend as a progress bar. You can call your methods however you want. So what happens here? init_project() initializes all map layers, making them invisible and removing all filter conditions. It copies the self.data dictionary as project variable into the QGIS project and then turns on the required layers. filter_layers() takes the user selected value of the Selector labeled District name (the drop down menu) to set a filter expression for the districts layer. set_extent() zooms Map 1 of our print layout poly to the now filtered extent of the districts layer. export_layout() finally exports the created map in the desired file format (PDF, PNG or SVG). It also writes the specific QGIS project file to the defined location, which can be handy for debugging your own autoMaps projects. Take a look at poly_out.qgz in QGIS, inspect the filter expressions and the poly print layout! The step methods use various helper methods, inherited from the MapGenerator base class, such as _set_map_layer_visibility() or _export_print_layout() . Take a look at the User Guide for a list of these helper methods. You don't have to use them in your own projects, you could directly go for the respective PyQGIS -calls instead. But they save you a lof of typing for the most common tasks. After running through all processing steps, the download button shows up on the frontend and the map is ready to be used. Feel free to play around with the demo project to get better acquainted with the overall structure of an autoMaps project. For further details on using autoMaps, please refer to the User Guide !","title":"The processing configuration (generate_poly.py)"},{"location":"getting_started/#creating-your-own-project","text":"You can now go back to the command line and create your first autoMaps project from scratch. Run the following command: automaps init-project PROJECT_NAME Replace PROJECT_NAME with the desired name. This will create a new directory with some stub files as starting point for your own project. Maybe you like to start with editing automapsconf.py which includes some hopefully helpful comments to get you started.","title":"Creating your own project"},{"location":"user_guide/architecture/","text":"","title":"Architecture"},{"location":"user_guide/cli/","text":"Command Line Interface #","title":"Command Line Interface"},{"location":"user_guide/cli/#command-line-interface","text":"","title":"Command Line Interface"},{"location":"user_guide/installation/","text":"Warning Only tested on Ubuntu 20.04! Requirements # autoMaps requires a recent version of Python , the Python package manager, pip , and the free and open source geographic information system QGIS to be installed on your system. You can check if you already have these installed from the command line: $ python --version Python 3 .8.2 $ pip --version pip 20 .0.2 from /usr/local/lib/python3.8/site-packages/pip ( python 3 .8 ) $ qgis --version QGIS 3 .18.1-Z\u00fcrich 'Z\u00fcrich' ( 202f1bf7e5 ) If you already have those packages installed, you may skip down to Installing autoMaps . Installing Python # Install Python using your package manager of choice, or by downloading an installer appropriate for your system from python.org and running it. Installing pip # If you're using a recent version of Python, the Python package manager, pip , is most likely installed by default. However, you may need to upgrade pip to the lasted version: pip install --upgrade pip If you need to install pip for the first time, download get-pip.py . Then run the following command to install it: python get-pip.py Installing QGIS # autoMaps uses QGIS , a free and open source geographic information system, to generate maps. Get it on the QGIS downloads page and install it first. You probably should be familiar with QGIS and at least a little bit of PyQGIS to get most out of autoMaps. Check out the QGIS documentation , if necessary. Installing autoMaps # Open your command line and clone the autoMaps repository: git clone https://github.com/itsviennaregion/automaps.git Change into the cloned directory: cd automaps Install the automaps package for the Python interpreter used by QGIS , for example like this: /usr/bin/python3 -m pip install . Info If you are not sure, which Python interpreter is used by QGIS, open the QGIS GUI and run the following commands in the Python console: import sys sys.executable This may return something like /usr/bin/python3 . Use the path to this Python interpreter in the command above.","title":"Installation"},{"location":"user_guide/installation/#requirements","text":"autoMaps requires a recent version of Python , the Python package manager, pip , and the free and open source geographic information system QGIS to be installed on your system. You can check if you already have these installed from the command line: $ python --version Python 3 .8.2 $ pip --version pip 20 .0.2 from /usr/local/lib/python3.8/site-packages/pip ( python 3 .8 ) $ qgis --version QGIS 3 .18.1-Z\u00fcrich 'Z\u00fcrich' ( 202f1bf7e5 ) If you already have those packages installed, you may skip down to Installing autoMaps .","title":"Requirements"},{"location":"user_guide/installation/#installing-python","text":"Install Python using your package manager of choice, or by downloading an installer appropriate for your system from python.org and running it.","title":"Installing Python"},{"location":"user_guide/installation/#installing-pip","text":"If you're using a recent version of Python, the Python package manager, pip , is most likely installed by default. However, you may need to upgrade pip to the lasted version: pip install --upgrade pip If you need to install pip for the first time, download get-pip.py . Then run the following command to install it: python get-pip.py","title":"Installing pip"},{"location":"user_guide/installation/#installing-qgis","text":"autoMaps uses QGIS , a free and open source geographic information system, to generate maps. Get it on the QGIS downloads page and install it first. You probably should be familiar with QGIS and at least a little bit of PyQGIS to get most out of autoMaps. Check out the QGIS documentation , if necessary.","title":"Installing QGIS"},{"location":"user_guide/installation/#installing-automaps","text":"Open your command line and clone the autoMaps repository: git clone https://github.com/itsviennaregion/automaps.git Change into the cloned directory: cd automaps Install the automaps package for the Python interpreter used by QGIS , for example like this: /usr/bin/python3 -m pip install . Info If you are not sure, which Python interpreter is used by QGIS, open the QGIS GUI and run the following commands in the Python console: import sys sys.executable This may return something like /usr/bin/python3 . Use the path to this Python interpreter in the command above.","title":"Installing autoMaps"},{"location":"user_guide/main_config/","text":"The main configuration # This section describes the structure and options of the main configuration of an automaps project. When initilizing a new project (see section Command Line Interface ) a default configuration file is created in the project folder. The configuration is done in a simple Python module. This allows a flexible setup, e.g. by splitting the configuration into multiple files. Mandatory configuration # The following mandatory options need to been set: MAPTYPES_AVAIL (List[MapType]) : This list needs to contain at least one instance of a MapType class. The MapType objects mainly hold information about the UI elements and their relationship with the project's input data. For further information see section The MapType class . QGIS_INSTALLATION_PATH (str) : This string variable holds a path to your QGIS installation, e.g. \"/usr\" . The path can be determined by opening up the QGIS GUI and running QgsApplication.prefixPath() in the Python console. FILEPATH_QGIS_PROJECT (str) : This string variable holds the path to the QGIS project associated with your autoMaps project (qgz or qgs file), e.g. \"./some_file_name.qgz\" . See section The QGIS project for further information. LOG_PATH (str) : This string variable holds the path where the log file should be written, e.g. \"./some_file_name.log\" . PORT_MAP_SERVER (int, defaults to 5656) : This integer variable sets the port for the communication between frontend and backend processes. If you have no reason to change it, leave the default as it is. PORTS_WORKERS : TODO PORT_REGISTRY : TODO Optional configuration # User Interface # PROJECT_TITLE (str) : This string variable sets the project title. The title will be shown in the sidebar menu. If the variable is not set, no title will be shown. PAGE_TITLE (str) : This string variable sets the page title, which will be shown in the browser tab. If the variable is not set, Streamlit's default title is used. Backend # LOG_LEVEL_SERVER (str) : This string variable sets the backend server's log level. It needs to be one of Python's logging modules levels, like DEBUG . If not set, the log level defaults to DEBUG . LOG_FORMAT (str) : TODO STATIC_PATH (str) : TODO from typing import List from automaps.maptype import MapType SHOW_DEBUG_INFO: bool PORT_MAP_SERVER: int QGIS_INSTALLATION_PATH: str DOWNLOADS_RETAIN_TIME: int LOGO_PATH: str FAVICON_PATH: str PROJECT_TITLE: str PAGE_TITLE: str MAPTYPE_TEXT: str MISSING_ATTRIBUTES_TEXT: str CREATE_MAP_BUTTON_TEXT: str WAITING_FOR_SERVER_TEXT: str NO_SERVER_AVAILABLE_TEXT: str SPINNER_TEXT: str MAP_READY_TEXT: str CUSTOM_HTML: str DOWNLOAD_BUTTON_STYLE: str FILEPATH_QGIS_PROJECT: str db: dict","title":"Main Configuration"},{"location":"user_guide/main_config/#the-main-configuration","text":"This section describes the structure and options of the main configuration of an automaps project. When initilizing a new project (see section Command Line Interface ) a default configuration file is created in the project folder. The configuration is done in a simple Python module. This allows a flexible setup, e.g. by splitting the configuration into multiple files.","title":"The main configuration"},{"location":"user_guide/main_config/#mandatory-configuration","text":"The following mandatory options need to been set: MAPTYPES_AVAIL (List[MapType]) : This list needs to contain at least one instance of a MapType class. The MapType objects mainly hold information about the UI elements and their relationship with the project's input data. For further information see section The MapType class . QGIS_INSTALLATION_PATH (str) : This string variable holds a path to your QGIS installation, e.g. \"/usr\" . The path can be determined by opening up the QGIS GUI and running QgsApplication.prefixPath() in the Python console. FILEPATH_QGIS_PROJECT (str) : This string variable holds the path to the QGIS project associated with your autoMaps project (qgz or qgs file), e.g. \"./some_file_name.qgz\" . See section The QGIS project for further information. LOG_PATH (str) : This string variable holds the path where the log file should be written, e.g. \"./some_file_name.log\" . PORT_MAP_SERVER (int, defaults to 5656) : This integer variable sets the port for the communication between frontend and backend processes. If you have no reason to change it, leave the default as it is. PORTS_WORKERS : TODO PORT_REGISTRY : TODO","title":"Mandatory configuration"},{"location":"user_guide/main_config/#optional-configuration","text":"","title":"Optional configuration"},{"location":"user_guide/main_config/#user-interface","text":"PROJECT_TITLE (str) : This string variable sets the project title. The title will be shown in the sidebar menu. If the variable is not set, no title will be shown. PAGE_TITLE (str) : This string variable sets the page title, which will be shown in the browser tab. If the variable is not set, Streamlit's default title is used.","title":"User Interface"},{"location":"user_guide/main_config/#backend","text":"LOG_LEVEL_SERVER (str) : This string variable sets the backend server's log level. It needs to be one of Python's logging modules levels, like DEBUG . If not set, the log level defaults to DEBUG . LOG_FORMAT (str) : TODO STATIC_PATH (str) : TODO from typing import List from automaps.maptype import MapType SHOW_DEBUG_INFO: bool PORT_MAP_SERVER: int QGIS_INSTALLATION_PATH: str DOWNLOADS_RETAIN_TIME: int LOGO_PATH: str FAVICON_PATH: str PROJECT_TITLE: str PAGE_TITLE: str MAPTYPE_TEXT: str MISSING_ATTRIBUTES_TEXT: str CREATE_MAP_BUTTON_TEXT: str WAITING_FOR_SERVER_TEXT: str NO_SERVER_AVAILABLE_TEXT: str SPINNER_TEXT: str MAP_READY_TEXT: str CUSTOM_HTML: str DOWNLOAD_BUTTON_STYLE: str FILEPATH_QGIS_PROJECT: str db: dict","title":"Backend"},{"location":"user_guide/map_generator/","text":"The MapGenerator class # Each generator class needs a class attribute name , a method _set_steps() and freely definable methods for map generation. The method _set_steps() must have the attribute self.steps of type OrderedDict[str, Step] . As keys speaking names of the processing step should be assigned as keys. These are also displayed in the frontend for information about the processing progress. The processing is carried out in the OrderedDict order. NamedTuples of type Step are expected as values, with the following attributes: * func (Callable) is the method defined in the class that executes the step. * weight (float) is the relative weight of the step with respect to the expected processing time (relative to the other steps). processing time (relative to the other steps of a map generator). This is used to display the progress bar in the frontend. Attention! : For each execution of a step a new instance of the MapGenerator is created! The attribute 'self' can therefore not be used to pass data between steps. between the steps. Instead, the attribute step_data of type StepData can be used instead, as can be seen in the example. For this purpose any attributes can be added to the object any attributes can be added. During initialization the associated QGIS project (defined in /conf_local.py ) and the print layout (defined with the argument print_layout ). in the configuration of the associated MapType in /conf.py ) are loaded. The two loaded objects are stored in self.step_data.project and self.step_data.layout and are and are available there for all processing steps. For example, a small generator class with three steps could look like this: from collections import OrderedDict from automaps.generators.base import MapGenerator , Step class MapGeneratorUeberblick ( MapGenerator ): name = \"\u00d6V-\u00dcberblick\" def _set_steps ( self ): self . steps = OrderedDict ( { \"Projektvariablen setzen\" : Step ( self . set_variables , 1 ), \"Layer filtern\" : Step ( self . filter_layers , 1 ), \"Kartenausschnitt festlegen\" : Step ( self . set_extent , 1 ), \"Karte exportieren\" : Step ( self . export_layout , 3 ), } ) def set_variables ( self ): self . _set_project_variable ( \"gemeinde_aktiv\" , self . data [ \"Gemeinde\" ]) def filter_layers ( self ): self . _set_map_layer_filter_expression ( \"bev_gemeinden\" , f \"pg = ' { self . data [ 'Gemeinde' ] } '\" ) def set_extent ( self ): self . _zoom_map_to_layer_extent ( \"Hauptkarte\" , self . _get_map_layer ( \"bev_gemeinden\" ) ) def export_layout ( self ): self . _export_print_layout ( self . step_data . layout )","title":"The MapGenerator Class"},{"location":"user_guide/map_generator/#the-mapgenerator-class","text":"Each generator class needs a class attribute name , a method _set_steps() and freely definable methods for map generation. The method _set_steps() must have the attribute self.steps of type OrderedDict[str, Step] . As keys speaking names of the processing step should be assigned as keys. These are also displayed in the frontend for information about the processing progress. The processing is carried out in the OrderedDict order. NamedTuples of type Step are expected as values, with the following attributes: * func (Callable) is the method defined in the class that executes the step. * weight (float) is the relative weight of the step with respect to the expected processing time (relative to the other steps). processing time (relative to the other steps of a map generator). This is used to display the progress bar in the frontend. Attention! : For each execution of a step a new instance of the MapGenerator is created! The attribute 'self' can therefore not be used to pass data between steps. between the steps. Instead, the attribute step_data of type StepData can be used instead, as can be seen in the example. For this purpose any attributes can be added to the object any attributes can be added. During initialization the associated QGIS project (defined in /conf_local.py ) and the print layout (defined with the argument print_layout ). in the configuration of the associated MapType in /conf.py ) are loaded. The two loaded objects are stored in self.step_data.project and self.step_data.layout and are and are available there for all processing steps. For example, a small generator class with three steps could look like this: from collections import OrderedDict from automaps.generators.base import MapGenerator , Step class MapGeneratorUeberblick ( MapGenerator ): name = \"\u00d6V-\u00dcberblick\" def _set_steps ( self ): self . steps = OrderedDict ( { \"Projektvariablen setzen\" : Step ( self . set_variables , 1 ), \"Layer filtern\" : Step ( self . filter_layers , 1 ), \"Kartenausschnitt festlegen\" : Step ( self . set_extent , 1 ), \"Karte exportieren\" : Step ( self . export_layout , 3 ), } ) def set_variables ( self ): self . _set_project_variable ( \"gemeinde_aktiv\" , self . data [ \"Gemeinde\" ]) def filter_layers ( self ): self . _set_map_layer_filter_expression ( \"bev_gemeinden\" , f \"pg = ' { self . data [ 'Gemeinde' ] } '\" ) def set_extent ( self ): self . _zoom_map_to_layer_extent ( \"Hauptkarte\" , self . _get_map_layer ( \"bev_gemeinden\" ) ) def export_layout ( self ): self . _export_print_layout ( self . step_data . layout )","title":"The MapGenerator class"},{"location":"user_guide/map_type/","text":"The MapType class # MapType is initialized with the following arguments: name (str) : Name of the map type. This must be used as a key in the variable GENERATORS . in /conf_server.py (see below). The name will be shown as main heading in the UI. It is also used to generate the radio button values for the available map types in the sidebar. description (str) : Description of the map type. Will be displayed in the frontend. ui_elements (Iterable[Union[MultiSelector, BaseSelector, Tuple[Callable, str]]) : Iterable of UI elements, being either selector objects or tuples of st.write and a string, e.g. (st.write, \"## heading\") . Selector objects are used to define the choices that are displayed in the UI. are defined. The selection will be displayed at the start of processing as self.data attribute. Tuples of the type (st.write, str) can be used to display texts in the UI, e.g. to display headings or further explanations. In the future other streamlit methods may also be supported. print_layout (Union[str, Tuple[str, Dict[str, str]]) : This will print the name of the text contained in the QGIS project file (see /conf_local.py ). print_layout must take one of the following two types: str : The name of the print layout in the associated QGIS project. tuple[str, Dict[str, str]] : At position 0 of tuple : The name of the selector, from which the name of the print layout is to be read At position 1 of the tuple : A mapping between the options of the selector and the corresponding names of the print layout. Example: print_layout=(\"map layout\", {\"external\": \"public transport overview area [external]\", \"internal\": \"Public transport overview area [internal]\", \"reduced\": \"Public transport overview area [reduced]\"}) html_beneath_name (str, optional) : This String can be used, to add arbitrary html code in the UI, right beneath the MapType name heading (e.g. to add custom links to a help page). Example: MAPTYPES_AVAIL : Dict [ str , MapType ] = { . \"Public transport overview\" : MapType ( name = \"\u00d6V-\u00dcberblick\" , description = \"This can be used to create a public transport overview.\" \"It works like this: ...\" , ui_elements = [ ( st . write , \"## basic settings\" ), SelectorSimple ( \"Spatial layer, [ \"line\" , \"municipality\" ], st . selectbox , widget_args = { \"help\" : \"Help text\" }, no_value_selected_text = \"Select spatial layer ...\" , ), SelectorSQL ( \"municipality\" , \"select distinct pg from bev_municipalities\" , st . selectbox , no_value_selected_text = \"select municipality ...\" , depends_on_selectors = { \"spatial_level\" : \"municipality\" }, ), ( st . write , \"## map elements\" ), SelectorSQL ( \"lines\" , \"\"\" select distinct line_name from pt_links l, communities g where g.name = '{{ data[\"municipality\"] }}' and ST_Intersects(l.geom, g.geom) \"\"\" , st . multiselect , additional_values = [ \"ALL\" ], depends_on_selectors = { \"spatial_level\" : \"municipality\" }, ), ], print_layout = \"test_layout\" , ), }","title":"The MapType Class"},{"location":"user_guide/map_type/#the-maptype-class","text":"MapType is initialized with the following arguments: name (str) : Name of the map type. This must be used as a key in the variable GENERATORS . in /conf_server.py (see below). The name will be shown as main heading in the UI. It is also used to generate the radio button values for the available map types in the sidebar. description (str) : Description of the map type. Will be displayed in the frontend. ui_elements (Iterable[Union[MultiSelector, BaseSelector, Tuple[Callable, str]]) : Iterable of UI elements, being either selector objects or tuples of st.write and a string, e.g. (st.write, \"## heading\") . Selector objects are used to define the choices that are displayed in the UI. are defined. The selection will be displayed at the start of processing as self.data attribute. Tuples of the type (st.write, str) can be used to display texts in the UI, e.g. to display headings or further explanations. In the future other streamlit methods may also be supported. print_layout (Union[str, Tuple[str, Dict[str, str]]) : This will print the name of the text contained in the QGIS project file (see /conf_local.py ). print_layout must take one of the following two types: str : The name of the print layout in the associated QGIS project. tuple[str, Dict[str, str]] : At position 0 of tuple : The name of the selector, from which the name of the print layout is to be read At position 1 of the tuple : A mapping between the options of the selector and the corresponding names of the print layout. Example: print_layout=(\"map layout\", {\"external\": \"public transport overview area [external]\", \"internal\": \"Public transport overview area [internal]\", \"reduced\": \"Public transport overview area [reduced]\"}) html_beneath_name (str, optional) : This String can be used, to add arbitrary html code in the UI, right beneath the MapType name heading (e.g. to add custom links to a help page). Example: MAPTYPES_AVAIL : Dict [ str , MapType ] = { . \"Public transport overview\" : MapType ( name = \"\u00d6V-\u00dcberblick\" , description = \"This can be used to create a public transport overview.\" \"It works like this: ...\" , ui_elements = [ ( st . write , \"## basic settings\" ), SelectorSimple ( \"Spatial layer, [ \"line\" , \"municipality\" ], st . selectbox , widget_args = { \"help\" : \"Help text\" }, no_value_selected_text = \"Select spatial layer ...\" , ), SelectorSQL ( \"municipality\" , \"select distinct pg from bev_municipalities\" , st . selectbox , no_value_selected_text = \"select municipality ...\" , depends_on_selectors = { \"spatial_level\" : \"municipality\" }, ), ( st . write , \"## map elements\" ), SelectorSQL ( \"lines\" , \"\"\" select distinct line_name from pt_links l, communities g where g.name = '{{ data[\"municipality\"] }}' and ST_Intersects(l.geom, g.geom) \"\"\" , st . multiselect , additional_values = [ \"ALL\" ], depends_on_selectors = { \"spatial_level\" : \"municipality\" }, ), ], print_layout = \"test_layout\" , ), }","title":"The MapType class"},{"location":"user_guide/overview/","text":"autoMaps User Guide #","title":"Overview"},{"location":"user_guide/overview/#automaps-user-guide","text":"","title":"autoMaps User Guide"},{"location":"user_guide/qgis_project/","text":"The QGIS project #","title":"The QGIS project"},{"location":"user_guide/qgis_project/#the-qgis-project","text":"","title":"The QGIS project"},{"location":"user_guide/streamlit_config/","text":"","title":"Streamlit Configuration"},{"location":"user_guide/ui_elements/","text":"Selector objects # The configuration of the selection options displayed in the UI is done with the help of Selector objects. BaseSelector classes Two selector classes derived from selector.BaseSelector are available: SelectorSimple : For lists of choices (e.g. \"bus\" or \"train\"), which are defined directly in conf.py . SelectorSQL : For lists of selections that are formed based on a database database query. These Selector classes share the following parameters for initialization: label (str) : name of the selector. Displayed in the UI. Furthermore the label can be used to define dependencies between the selectors of a MapType (see parameter depend (see depends_on_selectors` parameter). widget_method (Callable, optional) : One of the widgets provided by streamlit (e.g. st.radio or st.selectbox). If no argument or None is passed, no widget will be used in the UI, no widget for selecting values will be displayed. The list of options created (e.g. by an SQL query) will still be available and can be edited via the self.data attribute. self.data attribute of the associated MapType . With this mechanism can be used to execute SQL queries in the background, the results of which cannot be visible and selectable in the UI, but can be used by subsequent selectors. selectors. widget_args (dict, optional) : dictionary of arguments passed to initialize the widget object. of the widget object (e.g. {\"help\"=\"help text\"} ). no_value_selected_text (str, optional) : selection option to be displayed, before a value has been selected (e.g. \"Select spatial layer ...\"). depends_on_selectors (Union[List[str], Dict[str, Any]], optional) : This can be used to define conditions that must be met for the widget to be is displayed. This can be used to define dependencies between selectors. Either a list or a dictionary can be passed: Dictionary : As keys must be the labels of selectors also defined for the same MapType must be used as keys, as Values the values that must be selected for the corresponding selector. If e.g. the value \"line\" must be selected for the selector with the label \"spatial layer\", then depends then depends_on_selectors={\"Spatial layer\": \"Line\"}` must be set. Currently can only be checked for equality. If the dictionary contains more than one key/value pairs only one of the conditions must be met (OR operation). list : A list of selector labels of selectors of the same MapType . If the corresponding selectors contain either None or the default text ( no_value_selected_text ) as value, the widget will not be displayed. For example, a selector for public transport lines can only be displayed if first a municipality has been selected ( depends_on_selectors=[\"municipality\"] ). If the list list contains multiple selector labels, the widget will be displayed as soon as one of the listed listed selectors has a value selected (OR operation). label_ui (str, optional) : Alternative label of the widget to be displayed in the UI. should be displayed. optional (bool, optional, default False) : Indicates whether the widget is optional, i.e. whether map generation can be started even though the widget has the default value of ( no_value_selected_text ) or an empty list as result. Has influence on setting the has init values flag in the associated MapType . exclude_from_filename (bool, optional, default False) : If True then the value(s) of the selector will not be used to generate the filename. The SelectorSimple class is also initialized with the following parameter initialized: options (Iterable[Any]) : iterable of selectors. The SelectorSQL class additionally has the following initialization parameters: sql (str) : SQL statement that is sent to the database defined in db.ini and should return a list of selections, for example: \"select distinct linenumber from lines\" . The string can be [Jinja2](https://pypi.org/project/Jinja2/)-expressions to read the data dictionary with the selecting UI options. This allows the selected values of a selector defined in MapType as ui_element to be used in the SQL can be used in the SQL query of another selector. In the selection of bus lines can be limited to those lines that intersect the selected municipality. which intersect the selected municipality. For an example see above at MapType`. additional_values (Iterable[Any], optional) : iterable of additional choices that are prepended to the values obtained via SQL, e.g. [\"ALL\"] . Condition: the SQL statement returns at least one element. Otherwise, the additional values are not prepended. provide_raw_options (Boolean, optional) : The data dictionary of the associated MapType a new entry can be added. This has as key the selector with appended \" OPTIONS\" as key and all available options as value. options available, regardless of which one was selected in the UI. Default False`. MultiSelector class In addition to the two classes derived from BaseSelector there is the MultiSelector is available. This can be used to combine multiple selectors. These selectors should have mutually exclusive dependencies (defined with depends with depends_on_selectors ). The first selector passed via the selectors list, which returns a value not equal to None is used to create an entry in the data dictionary with the label of the MultiSelector as key. The MultiSelector class is initialized with the following parameters: * label (str) : name of the selector. Will be displayed in the UI. * selectors (List[BaseSelector]) : list of BaseSelector objects, see above. * exclude_from_filename (bool, optional, default False) : If True , then the selector's value(s) of the selector will not be used to generate the filename. Example: MultiSelector ( \"`stops`, [ SelectorSimple ( \"Stops a\" , [ \"All\" , \"None\" ], st . radio , depends_on_selectors = { \"Lines in the municipality\" : [], \"lines in district\" : [], \"lines in tender region\" : [], \"Lines in State\" : [], }, label_ui = \"stops\" , ), SelectorSimple ( \"Stops b\" , [ \"All\" , \"Stops served\" , \"None\" ], st . radio , depends_on_selectors = [ \"Lines in the municipality\" , \"Lines in district\" , \"Lines in tender region\" , \"lines in state\" , ], label_ui = \"Stops\" , ), ], ), Others #","title":"User Interface Elements"},{"location":"user_guide/ui_elements/#selector-objects","text":"The configuration of the selection options displayed in the UI is done with the help of Selector objects. BaseSelector classes Two selector classes derived from selector.BaseSelector are available: SelectorSimple : For lists of choices (e.g. \"bus\" or \"train\"), which are defined directly in conf.py . SelectorSQL : For lists of selections that are formed based on a database database query. These Selector classes share the following parameters for initialization: label (str) : name of the selector. Displayed in the UI. Furthermore the label can be used to define dependencies between the selectors of a MapType (see parameter depend (see depends_on_selectors` parameter). widget_method (Callable, optional) : One of the widgets provided by streamlit (e.g. st.radio or st.selectbox). If no argument or None is passed, no widget will be used in the UI, no widget for selecting values will be displayed. The list of options created (e.g. by an SQL query) will still be available and can be edited via the self.data attribute. self.data attribute of the associated MapType . With this mechanism can be used to execute SQL queries in the background, the results of which cannot be visible and selectable in the UI, but can be used by subsequent selectors. selectors. widget_args (dict, optional) : dictionary of arguments passed to initialize the widget object. of the widget object (e.g. {\"help\"=\"help text\"} ). no_value_selected_text (str, optional) : selection option to be displayed, before a value has been selected (e.g. \"Select spatial layer ...\"). depends_on_selectors (Union[List[str], Dict[str, Any]], optional) : This can be used to define conditions that must be met for the widget to be is displayed. This can be used to define dependencies between selectors. Either a list or a dictionary can be passed: Dictionary : As keys must be the labels of selectors also defined for the same MapType must be used as keys, as Values the values that must be selected for the corresponding selector. If e.g. the value \"line\" must be selected for the selector with the label \"spatial layer\", then depends then depends_on_selectors={\"Spatial layer\": \"Line\"}` must be set. Currently can only be checked for equality. If the dictionary contains more than one key/value pairs only one of the conditions must be met (OR operation). list : A list of selector labels of selectors of the same MapType . If the corresponding selectors contain either None or the default text ( no_value_selected_text ) as value, the widget will not be displayed. For example, a selector for public transport lines can only be displayed if first a municipality has been selected ( depends_on_selectors=[\"municipality\"] ). If the list list contains multiple selector labels, the widget will be displayed as soon as one of the listed listed selectors has a value selected (OR operation). label_ui (str, optional) : Alternative label of the widget to be displayed in the UI. should be displayed. optional (bool, optional, default False) : Indicates whether the widget is optional, i.e. whether map generation can be started even though the widget has the default value of ( no_value_selected_text ) or an empty list as result. Has influence on setting the has init values flag in the associated MapType . exclude_from_filename (bool, optional, default False) : If True then the value(s) of the selector will not be used to generate the filename. The SelectorSimple class is also initialized with the following parameter initialized: options (Iterable[Any]) : iterable of selectors. The SelectorSQL class additionally has the following initialization parameters: sql (str) : SQL statement that is sent to the database defined in db.ini and should return a list of selections, for example: \"select distinct linenumber from lines\" . The string can be [Jinja2](https://pypi.org/project/Jinja2/)-expressions to read the data dictionary with the selecting UI options. This allows the selected values of a selector defined in MapType as ui_element to be used in the SQL can be used in the SQL query of another selector. In the selection of bus lines can be limited to those lines that intersect the selected municipality. which intersect the selected municipality. For an example see above at MapType`. additional_values (Iterable[Any], optional) : iterable of additional choices that are prepended to the values obtained via SQL, e.g. [\"ALL\"] . Condition: the SQL statement returns at least one element. Otherwise, the additional values are not prepended. provide_raw_options (Boolean, optional) : The data dictionary of the associated MapType a new entry can be added. This has as key the selector with appended \" OPTIONS\" as key and all available options as value. options available, regardless of which one was selected in the UI. Default False`. MultiSelector class In addition to the two classes derived from BaseSelector there is the MultiSelector is available. This can be used to combine multiple selectors. These selectors should have mutually exclusive dependencies (defined with depends with depends_on_selectors ). The first selector passed via the selectors list, which returns a value not equal to None is used to create an entry in the data dictionary with the label of the MultiSelector as key. The MultiSelector class is initialized with the following parameters: * label (str) : name of the selector. Will be displayed in the UI. * selectors (List[BaseSelector]) : list of BaseSelector objects, see above. * exclude_from_filename (bool, optional, default False) : If True , then the selector's value(s) of the selector will not be used to generate the filename. Example: MultiSelector ( \"`stops`, [ SelectorSimple ( \"Stops a\" , [ \"All\" , \"None\" ], st . radio , depends_on_selectors = { \"Lines in the municipality\" : [], \"lines in district\" : [], \"lines in tender region\" : [], \"Lines in State\" : [], }, label_ui = \"stops\" , ), SelectorSimple ( \"Stops b\" , [ \"All\" , \"Stops served\" , \"None\" ], st . radio , depends_on_selectors = [ \"Lines in the municipality\" , \"Lines in district\" , \"Lines in tender region\" , \"lines in state\" , ], label_ui = \"Stops\" , ), ], ),","title":"Selector objects"},{"location":"user_guide/ui_elements/#others","text":"","title":"Others"}]}